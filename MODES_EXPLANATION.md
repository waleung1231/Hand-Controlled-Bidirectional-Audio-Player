# Hand-Controlled Audio Player: Mode Comparison and Mathematics

## Abstract

We present a gesture-controlled audio player that enables hands-free navigation through audio content using circular hand motions detected via MediaPipe hand tracking. The system implements two distinct control paradigms—Distance Mode and Speed Mode—that map rotational hand gestures to audio playback speed through fundamentally different mathematical approaches. Distance Mode employs an integrator-based architecture where rotation direction incrementally adjusts playback speed, creating a dial-like interface suited for precise, sustained speed control with configurable drift behavior. Speed Mode implements proportional control where angular velocity magnitude directly determines playback speed, creating a throttle-like interface for dynamic, expressive navigation that naturally returns to normal playback when stationary. Both modes utilize cross-product-based rotation detection from fingertip position sequences and employ multi-stage exponential smoothing through leaky integrators with adaptive alpha coefficients (0.01 when hand detected, 0.001 during drift) to ensure stable, jitter-free control. Forward playback leverages pitch-preserving HTML5 Audio time-stretching, while backward playback implements a novel chunk-based navigation system using Web Audio API with crossfaded segments to create intelligible reverse playback. The dual-mode architecture demonstrates how different mathematical mappings of the same input gesture can create distinct user experiences optimized for different interaction contexts, with Distance Mode favoring precision and persistence, and Speed Mode favoring responsiveness and natural decay. This work contributes both a practical hands-free audio control system and insights into designing gesture-based interfaces with multiple control paradigms.

---

This hand-controlled audio player uses MediaPipe hand tracking to detect circular hand gestures and translate them into audio playback control. The system offers two distinct control modes that fundamentally differ in how they interpret hand motion and map it to audio playback speed. Understanding these differences requires examining both the mathematical foundations underlying each mode and the user experience they create.

Both modes begin with the same core challenge: detecting rotational motion from a sequence of fingertip positions tracked at approximately 30 frames per second. The system tracks the index fingertip (landmark #8 in MediaPipe's hand model) and maintains a circular buffer of the five most recent positions along with their timestamps. To determine whether the hand is rotating, and in which direction, the system calculates motion vectors between consecutive positions and uses the cross product to detect rotation. Given two consecutive motion vectors v1 and v2, the cross product in 2D yields a scalar value: v1.x × v2.y - v1.y × v2.x. When this value is negative, the hand is rotating clockwise; when positive, it's rotating counter-clockwise; and when near zero, the motion is essentially linear rather than rotational. To remove the confounding effect of how fast the finger is moving across the screen, this cross product is normalized by dividing by the product of the vector magnitudes, yielding a pure measure of angular change that is independent of linear velocity.

Distance Mode and Speed Mode diverge in how they use this rotational information. Distance Mode treats rotation as a differential input, similar to turning a dial or steering wheel. When clockwise rotation is detected, a small fixed increment (0.05) is added to the current navigation speed, and when counter-clockwise rotation is detected, the same increment is subtracted. This creates an accumulative effect where sustained rotation in one direction builds up speed gradually over time. If the user rotates clockwise continuously, the speed will steadily increase from its current value toward the maximum of 4x, and if they rotate counter-clockwise, it will decrease, eventually crossing into negative territory for backward playback. The key characteristic of this mode is that the speed persists after the rotation stops; if a user rotates to build up to 2x speed and then holds their hand still, the speed doesn't immediately drop back down. Instead, it gradually drifts toward a configurable target speed (by default 0.7x) through a leaky integrator smoothing algorithm. This drift behavior is intentional, allowing users to set a playback speed and maintain it without continuous input, while still having the speed slowly return to a comfortable default when they stop paying attention.

Speed Mode, in contrast, treats rotation as a direct, proportional input where the intensity of the gesture immediately determines the playback speed. Rather than just detecting rotation direction, this mode calculates angular velocity by measuring how fast the rotation is occurring. The angular velocity is computed by dividing the average angular change by the frame duration, yielding a value in radians per second. This velocity value contains both magnitude (how fast the rotation is) and sign (which direction). The magnitude of this angular velocity is then scaled by a sensitivity factor (VELOCITY_SCALE = 8) and clamped to a range between 0.5x and 4x to determine the playback speed magnitude. The sign of the angular velocity determines the direction: negative angular velocity (clockwise rotation) maps to positive playback speed (forward playback), while positive angular velocity (counter-clockwise rotation) maps to negative playback speed (backward playback in chunks). The faster the user rotates their hand, the faster the audio plays or reverses, creating a direct, immediate relationship between gesture intensity and output. When the user stops rotating and holds still, Speed Mode doesn't maintain the current speed like Distance Mode does. Instead, it drifts back to 1x (normal playback speed), under the assumption that the natural resting state should be normal-speed playback rather than some arbitrary slower speed.

Both modes employ sophisticated smoothing to prevent jittery, unstable playback. The primary smoothing mechanism is a leaky integrator, a first-order exponential filter that causes the filtered playback speed to gradually approach the target speed set by the gesture. The filter operates according to the formula: filteredSpeed = filteredSpeed - α × (filteredSpeed - gestureTarget), where α (alpha) is a smoothing coefficient between 0 and 1. The system uses two different alpha values depending on whether a hand is detected. When a hand is actively detected, α = 0.01, providing relatively responsive tracking that follows gesture changes fairly quickly. When no hand is detected, α = 0.001, creating much slower drift that gently guides the speed back toward the target without abrupt changes. This dual-alpha approach means the system responds quickly to intentional gestures but slowly and gracefully handles the transition when the user removes their hand or stops moving. Speed Mode applies an additional layer of smoothing specifically to the input navigation speed to reduce flickering that can occur from frame-to-frame variations in measured angular velocity. This input smoothing uses another exponential filter with coefficient 0.3, creating a two-stage smoothing pipeline where the raw velocity measurement is first smoothed into navigationSpeed, which then feeds into the leaky integrator to produce the final filteredSpeed.

The choice of alpha values reflects a careful balance between responsiveness and stability, with each value serving a specific purpose in the control hierarchy. The primary leaky integrator alpha when a hand is detected (alphaFinger = 0.01) means that in each update cycle, the filtered speed moves 1% of the way toward the gesture target, creating a time constant of approximately 100 frames or about 3.3 seconds at 30 FPS. This relatively slow convergence prevents the playback speed from changing too abruptly when the user makes a new gesture, creating smooth acceleration and deceleration that feels natural and controlled rather than jarring. When no hand is detected (alphaNoFinger = 0.001), the alpha drops to one-tenth of the active value, meaning the filtered speed moves only 0.1% toward the target per frame, yielding a time constant of approximately 1000 frames or about 33 seconds. This extremely slow drift ensures that when the user removes their hand or the tracking temporarily loses the hand, the playback speed doesn't immediately snap to the drift target but instead gradually migrates there over many seconds, giving the user time to reposition their hand or adjust their gesture without experiencing disruptive speed changes. The configurable drift target in Distance Mode (default 0.7x) was chosen as a comfortable listening speed that's slightly slower than normal, allowing users to better comprehend content while still making reasonable progress through the audio, while Speed Mode's fixed drift target of 1.0x reflects the assumption that normal-speed playback is the most natural default state. In Speed Mode, the additional input smoothing coefficient of 0.3 operates at a faster timescale than the leaky integrator, smoothing out the raw angular velocity measurements before they even become the gesture target. This coefficient means that navigationSpeed moves 30% of the way toward the instantaneous velocity-based target speed in each frame, corresponding to a time constant of about 3.3 frames or roughly 0.1 seconds. This rapid smoothing removes high-frequency jitter from hand tremor and measurement noise while remaining responsive enough to track genuine changes in rotation speed, preventing the input speed slider from flickering wildly while still allowing it to follow intentional speed-up or slow-down gestures. Together, these three alpha values create a cascaded smoothing architecture where Speed Mode applies fast input smoothing (α = 0.3) followed by slow output smoothing (α = 0.01 or 0.001), while Distance Mode relies solely on the slow output smoothing since its incremental input is already inherently smoothed by the accumulation process. The result is a control system that feels responsive to intentional gestures yet stable and predictable, filtering out unwanted noise and jitter while preserving the user's intended control signals.

The audio playback mechanisms differ between forward and backward playback due to browser API limitations. Forward playback, which occurs when the speed is positive, uses the HTML5 Audio element's built-in playbackRate property, which provides pitch-preserving time-stretching. This means audio can be played faster or slower (within browser-dependent limits, typically 0.0625x to 16x) while maintaining the original pitch, so speech remains understandable even at 4x speed. Backward playback, however, cannot use this simple approach because browsers don't natively support negative playback rates. Instead, the system implements chunk-based navigation using the Web Audio API. When the playback speed is negative, the system extracts chunks of audio of a configurable duration (default 2.0 seconds) from the audio buffer, applies fade-in and fade-out envelopes to prevent clicking, and plays them using Web Audio API buffer sources. After each chunk plays, the system schedules the next chunk to start at a position earlier in the audio by a configurable step distance (default 1.5 seconds). The overlap between chunks (duration minus step) is crossfaded to create smooth transitions. Both the step distance and the interval between chunks are scaled by the absolute value of the playback speed, so faster reverse speeds cause larger jumps backward and shorter intervals between chunks, creating the perception of high-speed reverse playback while keeping each individual chunk intelligible.

The user experience of these two modes reflects their different mathematical foundations. Distance Mode feels like operating a rotary control, where the user gradually turns a dial to adjust playback speed and the setting persists after they let go. This mode excels at tasks requiring precise, sustained playback speeds, such as carefully reviewing a specific section at exactly 1.5x speed or methodically scrubbing backward through a recording. The incremental nature means users can make fine adjustments by rotating just a little bit, and the drift-to-target behavior means speeds will naturally settle at a comfortable default without requiring constant attention. Speed Mode, conversely, feels more like a throttle or accelerator pedal, where the energy put into the gesture directly determines the output. This creates a more dynamic, expressive control scheme where users can quickly sweep through content by rotating vigorously or move slowly by rotating gently. The instant response to gesture intensity makes Speed Mode excellent for exploratory navigation where the user wants to dynamically adjust speed in real-time based on what they're hearing, while the drift-to-normal behavior ensures that momentary inattention returns playback to a sensible default speed rather than leaving it stuck at whatever arbitrary value it happened to reach.

From a mathematical perspective, Distance Mode implements a discrete-time integrator with leaky drift, where the rotation direction serves as the input signal that increments or decrements an accumulated speed value that then slowly leaks toward a target. Speed Mode implements a proportional control system where the input (angular velocity) is directly mapped through a scaling function to the output (playback speed), with smoothing applied to both input and output to prevent instability. The sensitivity of Speed Mode is controlled by the VELOCITY_SCALE parameter: higher values require more vigorous rotation to achieve high speeds, while lower values make the system more sensitive to gentle rotations. Currently set to 8, this value was chosen to require moderately energetic rotation to reach maximum speed, providing a balance between ease of control and prevention of accidental high speeds from small movements. Distance Mode's sensitivity is controlled by the fixed increment value (0.05) and the drift alpha values, which together determine how quickly speed builds up during rotation and how quickly it decays during stillness.

The threshold for detecting rotation versus stillness plays a critical role in both modes. The system defines a minimum movement threshold of 0.015 (1.5% of screen width) below which fingertip position changes are ignored as noise or hand tremor. Additionally, the rotation velocity must exceed 0.12 radians per second to be considered active rotation; below this threshold, the hand is treated as stationary and drift behavior begins. These thresholds prevent tiny involuntary movements from being interpreted as intentional gestures while remaining sensitive enough to detect deliberate circular motions. The smoothing window of 5 frames and velocity calculation window of 10 frames provide sufficient averaging to filter out high-frequency noise while remaining responsive enough to track genuine gesture changes at the 30 FPS capture rate typical of webcams.

In summary, Distance Mode and Speed Mode represent two fundamentally different control philosophies applied to the same underlying gesture recognition system. Distance Mode treats hand rotation as a rate-of-change input that incrementally adjusts an accumulated speed value, creating a dial-like interface suited to precise, sustained speed control. Speed Mode treats rotational velocity as an absolute input that directly determines playback speed, creating a throttle-like interface suited to dynamic, expressive navigation. Both leverage cross-product-based rotation detection, multi-stage exponential smoothing, and intelligent drift behavior to create stable, usable interfaces, but they apply these mathematical tools in service of different interaction paradigms that appeal to different use cases and user preferences.
